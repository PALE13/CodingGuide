## 进程

#### **进程和线程的区别是什么？**

定义：进程是正在执行的程序的实例。它是操作系统分配资源的基本单位，拥有独立的内存空间和系统资源。线程是进程内的执行单元，是进程的一个执行流程。一个进程可以包含多个线程。

资源和隔离：每个进程都有独立的内存空间，包括代码、数据、堆栈等。进程之间的资源是相互隔离的，一个进程的崩溃不会影响其他进程。而线程是在进程内共享资源的，包括内存、文件句柄等。线程之间共享同一进程的资源，一个线程的错误可能会影响整个进程的稳定性。

调度和切换：操作系统通过调度算法来决定哪个进程获得CPU时间片进行执行。进程切换需要保存和恢复进程的上下文信息，代价较高。而线程是由操作系统调度的执行单位，线程切换的代价相对较低，因为线程共享同一进程的资源和上下文。

通信和同步：进程之间通信和同步的方式比较复杂，需要使用操作系统提供的机制，如管道、信号量、消息队列等。而线程之间共享进程的内存空间，可以通过共享变量直接进行通信和同步，但需要注意同步的安全性。

创建和销毁：创建和销毁进程的开销较大，需要操作系统进行资源分配和回收。而线程的创建和销毁开销相对较小，可以在进程内动态创建和销毁线程。

下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240310221800263.png" alt="image-20240310221800263" style="zoom: 50%;" />



从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)\**资源，但是每个线程有自己的\**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：**

- 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。
- 线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。
- 线程执行开销小，但不利于资源的管理和保护；而进程正相反。



#### **什么是协程**

定义：协程是一种轻量级的线程，可以在特定的时机进行挂起和恢复，以实现协作式多任务处理。它由程序员显示地控制执行流程，可以在代码中定义多个协程。

优点：
协程的切换开销很小，因为切换是由程序员控制的，不需要内核介入。
协程之间可以进行高效的通信和数据交换，减少了锁和同步机制的使用。
协程适用于高度并发的场景，能够提供更好的性能和资源利用率。

缺点：
协程需要程序员显式地管理执行流程，对编程模型要求较高。
协程无法利用多核处理器的并行性，只能在单个线程中执行。





#### **为什么要使用多线程?**

先从总体上来说：

- **从计算机底层来说：** 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **从当代互联网发展趋势来说：** 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

再深入到计算机底层来探讨：

- **单核时代**：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。
- **多核时代**: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。





#### **PCB 是什么？包含哪些信息？**

**PCB（Process Control Block）** 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。

当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。

PCB 主要包含下面几部分的内容：

- 进程的描述信息，包括进程的名称、标识符等等；

- 进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；

- 进程对资源的需求情况，包括 CPU 时间、内存空间、I/O 设备等等。

- 进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。

- 处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。

  



#### **进程有哪几种状态?**

我们一般把进程大致分为 5 种状态，这一点和线程很像！

- **创建状态(new)**：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)**：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)**：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)**：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)**：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240310222646581.png" alt="image-20240310222646581" style="zoom:67%;" />



#### **进程的调度算法有哪些?**

**先到先服务调度算法(FCFS，First Come, First Served)** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

**短作业优先的调度算法(SJF，Shortest Job First)** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

**时间片轮转调度算法（RR，Round-Robin）** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。

**高响应比优先（Highest Response Ratio Next，HRRN）**：是一种用于调度作业的优先级算法。它是根据作业的响应比来确定调度顺序的。响应比 = （等待时间 + 作业服务时间）/ 作业服务时间。优点是能够兼顾长作业和短作业，不会出现饥饿现象。

**多级反馈队列调度算法（MFQ，Multi-level Feedback Queue）**：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。

**优先级调度算法（Priority）**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

![image-20240310222750191](https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240310222750191.png)





#### **进程间的通信方式有哪些？**

> 下面这部分总结参考了:[《进程间通信 IPC (InterProcess Communication)》open in new window](https://www.jianshu.com/p/c1015f5ffa74) 这篇文章，推荐阅读，总结的非常不错。

**管道/匿名管道(Pipes)**：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。

管道是**半双工**的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。

只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);

单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，**单独构成一种文件系统，并且只存在与内存中**。

**管道的实质是一个内核缓冲区**

数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240323143826086.png" alt="image-20240323143826086" style="zoom: 67%;" />



**有名管道(Named Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 **先进先出(First In First Out)** 。有名管道以**磁盘文件的方式**存在，可以实现本机任意两个进程通信。**有名管道的名字存在于文件系统中，内容存放在内存中。**

**信号(Signal)**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。

如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。

如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。



**消息队列(Message Queuing)**

 （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.

（2）消息队列允许一个或多个进程向它写入与读取消息.

（3）管道和消息队列的通信数据都是先进先出的原则。

（4）消息队列可以**实现消息的随机查询**,消息不一定要以先进先出的次序读取,也可以按消息的类型读取，比FIFO更有优势。

（5）消息队列**克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**。

（6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。



**信号量(Semaphores)**：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于**进程间同步**。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

**共享内存(Shared memory)**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种**同步操作，如互斥锁和信号量**等。可以说这是最有用的进程间通信方式。

**套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是**不同主机之间的进程进行双向通信**的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。





#### **什么是僵尸进程和孤儿进程？**

在 Unix/Linux 系统中，子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。

当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。

这样的设计可以让父进程在子进程结束时得到子进程的状态信息，并且可以防止出现“僵尸进程”（即子进程结束后 PCB 仍然存在但父进程无法得到状态信息的情况）。

- **僵尸进程**：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，**导致子进程的 PCB 依然存在于系统中**，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，**父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。**
- **孤儿进程**：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。







#### **死锁和饥饿的区别**

**死锁：**一个进程集合内每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期僵持的现象。

**饥饿：**是一个可运行进程由于其它进程总是优先于它而被无期限拖延。

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240310224231762.png" alt="image-20240310224231762" style="zoom:67%;" />





#### **产生死锁的四个必要条件是什么?**

互斥条件：系统中存在临界资源，进程互斥访问这些资源。

不剥夺条件：进程获得的资源不能由其他进程夺走，只能主动释放。

请求和保持条件：进程请求资源得不到满足而等待，同时又继续占用已有资源。

循环等待条件：存在循环等待链，每个进程已获得的资源被下一个进程请求。

**注意 ⚠️**：这四个条件是产生死锁的 **必要条件** ，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。





#### **死锁的解决方法**

解决死锁的方法可以从多个角度去分析，一般的情况下，有**预防，避免，检测和解除四种**。

- **预防** 是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
- **避免**则是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**
- **检测**是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除** 是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**。

 **死锁的预防**

死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。

破坏第一个条件 **互斥条件**：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 **往往是不能同时访问的** ，所以这种做法在大多数的场合是行不通的。

破坏第二个条件 **非抢占**：也就是说可以采用 **剥夺式调度算法**，但剥夺式调度方法目前一般仅适用于 **主存资源** 和 **处理器资源** 的分配，并不适用于所有的资源，会导致 **资源利用率下降**。

所以一般比较实用的 **预防死锁的方法**，是通过考虑破坏第三个条件和第四个条件。

**1、静态分配策略**

静态分配策略可以破坏死锁产生的第三个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就**申请到它所需要的全部资源**，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。

静态分配策略逻辑简单，实现也很容易，但这种策略 **严重地降低了资源利用率**，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 **几乎不用的资源而使其他需要该资源的进程产生等待** 的情况。

**2、层次分配策略**

层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，**一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；**当一个进程要释放某层的一个资源时，**必须先释放所占用的较高层的资源，**按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。

**死锁的避免**

上面提到的 **破坏** 死锁产生的四个必要条件之一就可以成功 **预防系统发生死锁** ，但是会导致 **低效的进程运行** 和 **资源使用率** 。而死锁的避免相反，它的角度是允许系统中**同时存在四个必要条件** ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 **明智和合理的选择** ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。

我们将系统的状态分为 **安全状态** 和 **不安全状态** ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。

> 如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。

那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 **避免死锁算法** 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，**银行家算法** 通过先 **试探** 分配给该进程资源，然后通过 **安全性算法** 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 **真的分配资源给该进程**。

**死锁的检测**

对资源的分配加以限制可以 **预防和避免** 死锁的发生，但是都不利于各进程对系统资源的**充分共享**。解决死锁问题的另一条途径是 **死锁检测和解除** (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 **乐观锁** ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 **死锁的预防和避免** 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。

这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 **定时地运行一个 “死锁检测”** 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240310230430992.png" alt="image-20240310230430992" style="zoom:67%;" />























