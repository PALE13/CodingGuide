### 16-**设计模式**



**工厂模式**

为对象的创建提供一个接口，将具体创建的实现封装在接口之下，分离的对象的创建与使用，使得具体创建的实现改变不会对client类产生影响。

**三种工厂的关系**

当抽象工厂模式中只有一个产品等级结构时，抽象工厂模式退化为工厂模式。

当工厂模式只有一个工厂类，且类中方法为静态方法，工厂模式退化成简单工厂模式

简单工厂模式：工厂类职责过重，违背了OCP，加入新产品需要修改工厂

工厂模式：符合OCP，加入新产品，不需要修改抽象产品和抽象工厂

抽象工厂模式：若增加新的产品等级结构，违背OCP；若增加产品族，不违背OCP。



**单例模式：**

保证一个类只有一个实例，并且提供一个访问该实例的全局访问点

要点：私有化构造方法。私有化静态对象，提供公共的访问静态实例对象的方法。

只存在一个对象，节约系统资源

拓展困难，不符合单一职责原因

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221127005258591.png" alt="image-20221127005258591" style="zoom:50%;" />



**建造者模式**

适用于创建复杂的对象，产品与产品创建过程解耦

客户端不需要知道产品的内部细节

符合OCP，建造者可以用不同的具体建造者创建不同的对象

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221126224202621.png" alt="image-20221126224202621" style="zoom:50%;" />



**适配器模式**

为目标类适配不兼容的接口以复用代码

将目标类与适配器类解耦

符合OCP，适配者可以在不同的系统中复用

<img src="C:/Users/10379/AppData/Roaming/Typora/typora-user-images/image-20221126222216344.png" alt="image-20221126222216344" style="zoom:50%;" />

**桥接模式**

使抽象部分和实现部分分离，两个部分可以独立变化

符合OCP，可拓展性强

使用组合原则复用，保持了接口的灵活性

防止使用继承或多继承导致类的个数剧增

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221126222021406.png" alt="image-20221126222021406" style="zoom:50%;" />



**组合模式**

组合数个对象形成树形结构的关系，表示“整体-部分”的层次结构

适用于树形结构，可以一致的使用一个组合结构或单个对象

符合OCP，增加新的叶子构件和容器构件方便





<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221126224918199.png" alt="image-20221126224918199" style="zoom: 50%;" />



**装饰模式**

动态给对象添加额外的职责

具体构件类和具体装饰类可以独立变化

比继承有更好的灵活性，不会导致类个数的剧增

符合OCP，可以动态为一个对象添加功能



装饰模式和桥接模式区别：

装饰者和被装饰者没有主次之分，继承同一个抽象构件

桥接者和被桥接者是平等的，不用继承同一个父类

都能处理类扩散的情况

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221126231248259.png" alt="image-20221126231248259" style="zoom:50%;" />

**外观模式**

为子系统中一组接口提供统一的入口（总开关）

降低子系统和客户端的耦合

减少客户端需要处理对象的数目，降低系统复杂度

违背OCP原则，增加子系统需要修改外观类，需要引入抽象外观



<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221127001623740.png" alt="image-20221127001623740" style="zoom: 50%;" />

**代理模式**

客户端不能访问真实主题，需要通过代理

代理起到中介的作用，去掉了客户不能看到的内容或为客户添加额外服务

符合OCP，针对抽象主题编程，更换代理无需修改源代码

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221127004145238.png" alt="image-20221127004145238" style="zoom:50%;" />



**策略模式：**

将可变的部分从程序中抽离成算法接口，在该接口下分别封装一些列算法实现并使他们可以相互替换，从而导致客户端独立于算法的改变。

**优点：（19）**

减少算法类与客户端之间的耦合。

使用了组合复用原则，实现更加灵活，更好地应对变化

符合开闭原则，有良好的可拓展性，新增策略类无需修改代码

消除大量条件语句，消除控制耦合和逻辑内聚。

**缺点：（19）**

产生较多的策略类

策略需要对外暴露，客户端需要了解每个策略的实现细节决定使用哪个策略

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221127011750675.png" alt="image-20221127011750675" style="zoom: 67%;" />



**迭代器模式**

提供一种可以遍历聚合对象的方式

聚合类中有集合的引用，可以创建相应集合的迭代器

只提供对聚合类访问的方法，屏蔽了对聚合类修改的方法

优点：符合OCP，若增加新的聚合类，只需增加新的具体迭代器

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221128005332594.png" alt="image-20221128005332594" style="zoom:50%;" />

**观察者模式**

定义对象之间的一种一对多的依赖关系，当一个对象状态发生改变时，其依赖对象都能得到通知并自动更新

目标提供增加和删除观察者的方法，当状态发生改变时通知观察者

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221129015405713.png" alt="image-20221129015405713" style="zoom:50%;" />





**责任链模式**

为请求创建一个接收者对象的链条，让多个对象都有可能接收请求，每个接收者都有下一个接收者的引用

用于发送者和接收者的解耦，如果请求和接收都写在一个类中不满足单一职责原则和OCP

抽象处理者与自身聚合，具体处理者如果满足请求则处理，不满足则调用下一个具体处理者处理

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221129020838694.png" alt="image-20221129020838694" style="zoom: 50%;" />





**中介者模式**

定义一个对象来封装一系列对象的交互，降低多个对象交互的复杂性，使他们之间不需要显示引用

中介者通过封装同事类之间的交互，解除了各个同事之间的耦合

当同事执行change时，会将交互交给中介者处理

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221129023725867.png" alt="image-20221129023725867" style="zoom:50%;" />





**命令模式**

引入抽象命令类和具体命令类，请求发送和只需指定一个命令对象就能调用请求接收者完成处理

降低发送者和接收者的耦合度，隐藏接收者的实现细节

命令模式和策略模式的区别：

命令模式是含有不同的命令（含有接收者的请求），做不同的事情，隐藏接收者执行细节。

而策略模式含有不同的算法，做相同的事情。

![image-20221129031109383](https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221129031109383.png)

**备忘录模式**

在不破坏封装的前提下，通过备忘录捕获一个对象的内部状态，并在该对象之外保存这个状态，使得该对象可以回到某个历史的状态

负责人通过引用备忘录保存备忘录的状态，但不能对其进行修改

缺点：如果类的成员变量较多，比较占用资源



<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221129210643111.png" alt="image-20221129210643111" style="zoom:50%;" />



**状态模式**

允许一个对象在其内部状态改变时改变它的行为

状态类与环境类相互引用，环境类执行操作时，调用相应的状态执行操作，状态类执行操作后判断是否需要状态装换

拓展性强，增加新的状态方便

与策略模式的区别：

策略模式定义了一组可互相代替的算法，这一组算法对象完成的是同一个任务

状态模式不同的状态完成的任务完全不一样



<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221129221527751.png" alt="image-20221129221527751" style="zoom:50%;" />



**模板方法模式**

父类提供一个定义算法框架的模板方法，封装了算法的执行步骤

把不变的方法在父类实现，子类可以拓展新的方法，符合OCP

提高代码的复用性，减少重复代码

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221130000527508.png" alt="image-20221130000527508" style="zoom:50%;" />

**访问者模式**

将数据结构与操作这些数据结构分离

不同访问者对不同的元素的操作不同，每有一种元素访问者就多一种访问方法

通过对象结构来遍历元素来接收访问者的访问

符合OCP，增加新的访问者比较方便，适用于结构对象稳定的系统

缺点：元素对象变更需要修改访问者

<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20221130015928366.png" alt="image-20221130015928366" style="zoom:50%;" />